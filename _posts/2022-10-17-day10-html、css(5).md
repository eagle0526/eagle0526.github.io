---
title: ASTRO Camp Day10 - HTML(05)
author: YeeChen
date: 2022-10-17
category: html、css
layout: post
---

今日教學大綱
------
 - order
 - flex-grow
 - flex-basis
 - position


order
-----

- 所有子物件的order值都預設為0  
- 只要要給一個order值，他就會跑到後面去  
- 排序位置，跟主軸方向有關  

### 實際測試 - 把div 2 換到最右邊

```markdown
> HTML

> <div class="flex">
>     <div class="item">1</div>
>     <div class="item">2</div>
>     <div class="item">3</div>
> </div>
```

```markdown
> CSS

> .flex {
>     width: 500px;
>     height: 500px;
>     background-color: aquamarine;
>     display: flex;
>     flex-wrap: wrap;
> }
> 
> .item {
>     width: 100px;
>     height: 100px;
>     margin: 10px;
>     background-color: aliceblue;
>     font-size: 20px;
> }
> 
> .item:nth-child(2) {
>     background-color:blanchedalmond ;
>     order: 1;
> }
```


flex - grow
------

- 伸展值  
- 拿取所有剩餘空間  
- 誰擁有flex grow 越多，就可以分到越多剩餘空間  

```markdown
> .item:nth-child(1) {
>     flex-grow: 1;          -> 剩餘空間拿1份
> }
> 
> .item:nth-child(3) {
>     flex-grow: 2;          -> 剩餘空間拿兩份
> }
```

flex-shrink
------

縮減值  
每個物件都有flex-shrink屬性  
如果設定 flex-shrink 設定為0，flex 就會失去收縮  


```markdown
> HTML

> <div class="flex">
>     <div class="item">1</div>
>     <div class="item">2</div>
>     <div class="item">3</div>
> </div>
```

```markdown
> CSS

> .flex {
>     width: 500px;
>     height: 500px;
>     background-color: aquamarine;
>     display: flex;
>     /* flex-wrap: wrap; */              -> 把flex換行關掉 
> }
> 
> .item {
>     width: 200px;
>     height: 100px;
>     margin: 10px;
>     background-color: aliceblue;
>     font-size: 20px;
>     flex-shrink: 0;                     -> 讓三個物件的伸縮值變0(會突破父層的寬度)
> }
> 
> .item:nth-child(2) {
>     background-color:blanchedalmond ;
>     flex-shrink: 1;                     -> 讓子層的第二個div，flex值設定為1，該div值會收縮到整個可以被父層包住
> }
```


#### 另一種比較少見的排版法 - 不用算寬度的寫法
test.html

flex-grow + max-width + justify-content

```markdown
> HTML

> <div class="flex">
>     <div class="item">1</div>
>     <div class="item">2</div>
>     <div class="item">3</div>
> </div>
```


```markdown
> CSS

> .flex {
>     /* width: 500px; */              -> 父層不設定高度
>     height: 500px;
>     background-color: aquamarine;
>     display: flex;
>     /* flex-wrap: wrap; */           -> 不要讓子物件換行
>     justify-content: space-evenly;   -> 讓子層物件置中
> }
> 
> .item {
>     width: 0px;                      -> 每個子物件不要設定寬度
>     height: 100px;
>     background-color: aliceblue;
>     font-size: 20px;
>     flex-grow: 1;                    -> 讓每個物件都可拿取剩餘寬度
>     max-width: 400px;                -> 限制子層的最大寬度
> }
> 
> .item:nth-child(2) {
>     background-color:blanchedalmond ;
> }
> 
> .item:nth-child(3) {
>     background-color:brown ;
> }
```



flex-basis
-----

基本值是子物件在主軸上的長度  
ps. 主軸是左到右的時候，基本值是寬、主軸是上到下的時候，基本值是高度  

**basis跟寬高衝突的時候，basis優先**  


> --  
> flex-grow、flex-shrink 是不衝突的，兩種作用情境不同  
> --  
{: .block-tip}





後台管理的切版設定 
------


```markdown
> HTML

> <div class="flex">
>     <div class="item">側邊欄</div>    -> 左側固定側邊欄
>     <div class="item">工作列</div>    -> 右側彈性工作列
> </div>
```



#### 方法一
- 一個父層 100%  
- 左邊側欄固定寬 300px  
- 右側寬度為0 - w: 0px + flex-grow: 1  (右側把剩下寬度都吃掉)  


```markdown
> .flex {
>     width: 100%;
>     height: 500px;
>     background-color: aquamarine;
>     display: flex;
> 
> }
> 
> .item:nth-child(1) {
>     background-color:blanchedalmond ;
>     width: 300px;
>     outline: 1px solid tomato;
> }
> 
> .item:nth-child(2) {
>     background-color:blanchedalmond ;
>     outline: 1px solid brown;
>     width: 0%;
>     flex-grow: 1;
> }
```


#### 方法二

- 父層 100%  
- 左側固定寬 200px - flex-shrink: 0; -> 不收縮  
- 右側100% - flex-shrink: 1; -> 收縮  

```markdown
> .flex {
>     width: 100%;
>     height: 500px;
>     background-color: aquamarine;
>     display: flex;
> 
> }
> 
> .item:nth-child(1) {
>     background-color:blanchedalmond ;
>     width: 300px;
>     outline: 1px solid tomato;
>     flex-shrink: 0;
> }
> 
> .item:nth-child(2) {
>     background-color:blanchedalmond ;
>     outline: 1px solid brown;
>     width: 100%;
>     flex-shrink: 1;
> }
```




> --  
> 寬、高度優先 - 當多種寬度設定衝突時，哪個優先權最高  
> min-width > max-width > flex-basis > width  
> --  
{: .block-warning}


***


position
-----

static      -> 靜態 -> 把所有定為無效化(超級少用到)

中間三個常用
relative    -> 相對定位 -> 偏移顯示
fix         -> 固定定位
absolute    -> 絕對定位

比較慢出來
sticky      -> 黏貼

```markdown
> <div class="flex">
>     <!-- .item.item${$}*40 -->           -> 叫做下面所有東西的快速鍵
>     <div class="item item1">1</div>
>     <div class="item item2">2</div>
>     <div class="item item3">3</div>
>     <div class="item item4">4</div>
>     <div class="item item5">5</div>
>     <div class="item item6">6</div>
>     <div class="item item7">7</div>
>     <div class="item item8">8</div>
>     <div class="item item9">9</div>
>     <div class="item item10">10</div>
>     <div class="item item11">11</div>
>     <div class="item item12">12</div>
>     <div class="item item13">13</div>
>     <div class="item item14">14</div>
>     <div class="item item15">15</div>
>     <div class="item item16">16</div>
>     <div class="item item17">17</div>
>     <div class="item item18">18</div>
>     <div class="item item19">19</div>
>     <div class="item item20">20</div>
>     <div class="item item21">21</div>
>     <div class="item item22">22</div>
>     <div class="item item23">23</div>
>     <div class="item item24">24</div>
>     <div class="item item25">25</div>
>     <div class="item item26">26</div>
>     <div class="item item27">27</div>
>     <div class="item item28">28</div>
>     <div class="item item29">29</div>
>     <div class="item item30">30</div>
>     <div class="item item31">31</div>
>     <div class="item item32">32</div>
>     <div class="item item33">33</div>
>     <div class="item item34">34</div>
>     <div class="item item35">35</div>
>     <div class="item item36">36</div>
>     <div class="item item37">37</div>
>     <div class="item item38">38</div>
>     <div class="item item39">39</div>
>     <div class="item item40">40</div>
> </div>
```




relative
------

top - 要距離原本物件的上緣多少  
left - 要距離原本物件的左緣多少  

如果今天同時設定left、right，系統會依照你語言文字的方向，來決定哪一個要作用  
ex.如果是左~右，left會觸發，right會無效  


```markdown
> .flex {
>     display: flex;
>     flex-wrap: wrap;
> }
> 
> .item {
>     width: 100px;
>     height: 100px;
>     background-color: gainsboro;
>     margin: 5px;
>     font-size: 20px;
> }
> 
> .item20 {
>     background-color:brown ;
>     position: relative;
>     top: 100px;
>     left: 100px;
>     
> }
```


> #### 物件排序規則  
> --  
> 1、如果今天有一個物件設定了定位，會蓋住沒定位的物件  
> 2、有定位的物件，z-index會比沒定位的還高  
> 3、如果兩者都有定位，會依照原始碼的順序  
> --  
{: .block-tip}

> --  
> #### 只要Z軸調不了，就要想到這幾個事情  
> 1、 只要你的定位**不是static**，你的z-index都有效  
> 2、 當你的父層是flex 你的 z-index都有效  
> 3、 當你的父層是grid，也是有效  
> 4、 擁有opacity，z-index是比較高的   
> --  
{: .block-warning}



fix 
------

設定fix的物件，會脫離資料流去排列，而他參考的空間是視窗




