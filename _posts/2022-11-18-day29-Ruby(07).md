---
title: ASTRO Camp Day29 - Ruby(07)
author: YeeChen
date: 2022-11-18
category: Ruby
layout: post
---



會員系統 User model
------

WishList第二個MODEL => user會員系統

新增會員會有的路徑
```md
/users/new       => 會員註冊又等於新增user
/users/create    
/users/show      => show出會員資料
/users/edit      => 修改會員資料
/users/update     
/users/destroy   => 刪除會員資料
```


user路徑創造，我們這邊使用單數的resource，這樣show不用帶id
```md
> resource :user
```

> --  
> **resource使用慣例**  
> 單數 :單數  
> 複數 :複數  
> --  
{: .block-tip}

> --  
> **resource + only**  
> 路徑也可以這樣寫，這樣可以限制只產生指定action的路徑  
> resource :user, only:[:index, :show]  
> --  
{: .block-tip}



要記得把筆記寫完，應該是11/18 - 第二個影片
### resource :user Vs. resources :users


**把這兩者的路徑全部印出來**
resource :user

沒有format :id


**把這兩者的路徑全部印出來**
resources :users

有format :id







> --  
> 在做前台，不應該讓網址帶有id，像是會員系統的id、購物車的id，都不用讓它帶有id  
> --  
{: .block-warning}





User會員系統的CRUD
------

### 第一步驟 navbar

因為登入連結通常會做在navbar上，所以我們做一個navbar出來  
不過因為是全站都看得到，所以寫在layout那邊  
```md
> <nav id="nav">
> 
>     <%= link_to "註冊", new_users_path %>
>     <%= link_to "登入", "#" %>
>     <%= link_to "登出", "#" %>
> 
> </nav>
```

但是還記得之前我們做的shared資料夾嗎？我們可以把nav放在這邊，並用render渲染過去
```md
> <body>
>     <%= render "shared/navbar" %>           # 這一行
>     <%= render "shared/flash" %>
>     <%= yield %>
> </body>
```




### 第二步驟 form_with

new頁面用form_with做表單，要注意事項
```md
> <%= form_with(model: @user) do |form| %>
>     <div>
>       <%= form.label :nickname %>
>       <%= form.text_field :nickname %>
>     </div>
>     <div>
>       <%= form.label :email %>
>       <%= form.email_field :email %>
>     </div>
>     <div>
>       <%= form.label :password %>
>       <%= form.password_field :password %>
>     </div>
> 
>     <%= form.submit "註冊" %>
> <% end %>
```



but!!!，會發現form_with，會找不到users_path，因此要來更改一下路徑  
```md
> resource :user, as: "users"  
```
這個可以把path變成都是負數  
不過要記得在路徑後面+as 動的是 prefix，實際上網址還是單數  






### 第三步驟 密碼再次輸入

### confirmation
密碼再次確認的欄位 password_confirmation  
model的confirmation方法，用這個東西可以不用再幫model開欄位，rails會幫你做雙重確認   
  
  
user的model
```md
> class User < ApplicationRecord
>     validates :email, presence: true
>     validates :password, confirmation: true             #加上密碼確認
> end
```

user的view，增加這個欄位
```md
> <div>
>     <%= form.label :password_confirmation %>
>     <%= form.password_field :password_confirmation %>
> </div>
```

#### length

再多加一個條件，密碼最小長度不能小於6個字 -> length: {minimum: 6}

user的model
```md
> class User < ApplicationRecord
>     validates :email, presence: true
> validates :password, confirmation: true, length: {minimum: 6}  # 最小長度
> end
```




### 第四步驟 user_params

做user的create，create的流程，記得先做資料驗證的方法(password_confirmation要記得給進去喔)  
然後可以先把它params出來看看，會發現

```md
> def create
>     render html: user_params
> end
> 
> 
> private
> def user_params
>     params.require(:user).permit(:nickname, :email, :password, :password_confirmation)
> end
```


### 第五步驟 create user

把create寫進資料庫

```md
> def create
>     @user = User.new(user_params)
> 
>     if @user.save
>         redirect_to root_path, notice: "註冊成功"
>     else
>         render :new
>     end
> end
```


### 第六步驟 密碼加密

官網詳細callback => [callback流程](https://guides.rubyonrails.org/active_record_callbacks.html)  
  
Ps. creating an object -> 會有一整個週期，所以我們現在create物件時，要在某個階段，對密碼作加密  

**密碼加密原理**
為啥要密碼加密呢？因為沒加密的話，存到資料庫的資料是使用者真實輸入的值，沒有轉換過，這樣是不對的  
使用雜湊演算法 MD5 SHA1 SHA256  
假設你今天的輸入值是123，他的輸出值會一樣  
    
第一次輸入的時候，密碼會用加密演算法，轉成一段亂碼後，並把他丟進資料庫  
之後還要進入此網站的話，使用者會再輸入一次密碼，如果密碼一樣，演算法轉出來的輸出值也會一樣  
這樣就可以登入了  
  
資料庫存的是被演算法轉換後的結果  

User 的 model
```md
> class User < ApplicationRecord
> 
>     ....這邊有兩個validate(先省略)
> 
>     before_save :encrypt_password                                 -> 設定好加密後，在before_save階段
> 
>     private
>     def encrypt_password
>         # HASH 
>         # self.password = 編碼過的password
>         self.password = Digest::SHA1.hexdigest(self.password)         -> ruby官網有標準函式庫可以做此加密
>     end
> end
```



#but

before_save 不只在create階段有，update階段也有，因此不能放在before_save，如果放在這邊，update還會讓加密被加密一次

要改成before_create
```md
> before_create :encrypt_password                                 -> 改成before_create
```



#### 還是不夠安全

透過sha-1加密後，還是覺得不夠安全，我們現在來增加密碼複雜度(這個動作稱為灑鹽 salting)

```md
> self.password = Digest::SHA1.hexdigest("xy#{elf.password}zz")        # 在原本密碼上加別的字串，增加複雜度
```

> --  
> ### 鹽(密碼學)  
> 在密碼學中，是指在雜湊之前將雜湊內容（例如：密碼）的任意固定位置插入特定的字串。  
> 這個在雜湊中加入字串的方式稱為「加鹽」。其作用是讓加鹽後的雜湊結果和沒有加鹽的結果不相同，  
> 在不同的應用情景中，這個處理可以增加額外的安全性。  
{: .block-tip}



> --  
> **清掉資料庫所有資料**  
> 到rails c  
> User.destroy.all  
> Ps. 這個指令使用要小心  
> --  
{: .block-warning}



### 第七步驟 登入路徑

登入 : /user/login (不過目前沒有此路徑)

11/18 12.30 說明member、collection的差異

```md
> resource :user, as: "users" do
>     # /user/login                     # 我想要的網址是這條
>     collection do                     # 用collection可以製造出上面那一條路徑
>         get :login
>     end
> 
> end
```


創好路徑後，就可以把login的action、view設定好了




### 第八步驟

**新增session的路徑**  
為什麼要新增這個路徑呢？  
因為在做登入/登出的時候，其實算是額外不屬於user model的行為  
因此你拿著只要拿著號碼牌，就可以登入、登出，所以我們把兩者分開寫  

Ps. 我們的session路徑只需要新增和刪除
```md
> resource :session, only: [:create, :destroy]
```











