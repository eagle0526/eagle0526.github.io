---
title: ASTRO Camp Day30 - Ruby(08)
author: YeeChen
date: 2022-11-21
category: Ruby
layout: post
---



軟刪除
------

什麼是軟刪除？？
假設今天要刪除許願卡，正常要刪除這個卡片，就是直接對這個卡片destroy就好了，不過通常我們在做刪除的時候
都不會讓資料真的消失，那要怎麼辦到呢？要怎麼讓消費者覺得真的有刪掉東西，但是其實是假的，資料庫其實還是有那一筆資一料
這就就是我們今天要做的

要怎麼做到呢？
首先我們在在許願卡身上多開一個is_deleted的欄位，此欄位的預設值是false，假設今天許願卡被刪掉了，我們更改的
是這個欄位，把此欄位改成true，之後我們撈資料，要記得撈所有的許願卡，該欄值為false的許願卡，要不然會把已經
被刪除(is_deleted: true)的許願卡也撈出來喔！！！！！！

```md
> def index
>   @wishlists = WishList.all     -> 撈全部資料的時候，要記得撈is_deleted: false的許願卡
> end
```

撈資料範例，這樣就可以撈出已經被刪掉的資料(假裝被刪掉)
```md
def find_wish_list
  @wish_list = current_user.wish_lists.find_by!(id: params[:id], is_deleted: false)
end
```


不過我們今天換一種軟刪除的方法，在欄位上面加這個
給一個刪除的時間欄位，預設值給空，這種方式的好處是，可以知道該筆資料啥時被刪除了
```md
> t.datetime "deleted_at", default: nil
```
  
  
### 第一步驟 - 開欄位  
那接下來我們就來開欄位了
```md
> rails g migration add_deleted_at_to_wishlist
```
  
migration的內容，增加欄位並且加上index
```md
> class AddDeletedAtToWishlist < ActiveRecord::Migration[6.1]
>   def change
>     add_column :wish_lists, :deleted_at, :datetime
>     add_index :wish_lists, :deleted_at
>   end
> end
```

> --  
> 為欄位加上index的好處是什麼？？  
> 可以幫助加速查找資訊  
> --  
{: .block-tip}


接下來具現化表單
```md
> rails db:migrate
```


為許願卡加上欄位後，要來處理刪除功能了，我們預計要做到的是，點下刪除
的按鈕/連結，可以把剛剛新增的欄位，變成true的狀態


### 第二步驟 更新deleted_at
因此首先到wish_list的controller更改東西
```md
> 點下刪除的時候，去更新這個欄位(直接更新此欄位的時間 -> 意思是刪除的時候，可以知道是啥時刪除的)

> def destroy
>   @wish_list.update(deleted_at: Time.current)
> end
> redirect_to root_path, notice: "資料已刪除"
```


### 第三步驟 index過濾刪掉的東西
並且讓前台顯示的東西，我們去抓deleted表格為nil的值(為啥是這樣抓呢？因為只要這個欄位是有被寫進時間的，代表是被刪掉的)
```md
> @wish_lists = current_user.wish_lists.where(deleted_at: nil)
```


### 第四步驟 find_wish_list過濾
find方法也要改，讓show..等功能也可以過濾刪除功能
```md
> def find_wish_list
>     @wish_list = current_user.wish_lists.find_by!(id: params[:id], deleted_at: nil)
> end
```

  
但是我們用第三、四步驟來做篩選，會有一個問題  
假設今天專案不是你一個人做的，是很多人協作的，如果有人看不懂你寫的，不小心把沒有過濾好  
不小心把沒過濾的假刪除資料給放出去，那不就出大事了嗎！！？  
  
所以我們現在要來做一些嚴謹的設定 -> 使用scope在model來做設定  
  
> --  
> 寫scope有兩個好處  
> 一、可以重複使用  
> 二、可以賦予意義 -> 這個很重要，設定的好，可以一眼就看出來篩選了哪些欄位  
> --  


**11.21 11:19 scope 教學**  

到wishlist的model來設定scope
```md  
> **定義not_deleted此scope，意義是沒刪除的許願卡**
> scope :not_deleted, -> {where(deleted_at: nil)}  
```

接下來到controller改寫，只要套用not_deleted，就可以達成過濾的目的，用find_wish_list舉例
```md
> def find_wish_list
>     @wish_list = current_user.wish_lists.not_deleted.find_by!(id: params[:id])
> end
```
Ps. 在model做限制，就可以讓controller都套用  
  
  
！！！但是，我們雖然寫了一個過濾方法，還是有可能會忘記用，我們來直接用default_scope，來強制使用
```md
> 用default_scope 用這種方法，所有搜尋方法都會經過他(find、find_by、where)

> default_scope -> {where(deleted_at: nil)} 
```





再優化一下wish_list destroy的功能，直接在寫一個新的destroy在model，這樣可以讓controller那邊使用
這個destroy是特別的destroy，他可以更新deleted_at(簡單說就是把目前寫得搬到model)
這樣的好處是，可以讓別人看此action，就像是一般的destroy，實際上是有規則的destroy

```md
> WishList的model

> def destroy
>   update(deleted_at: Time.current)
> end
```

controller正常寫法就可以
```md
> def destroy
>   @wish_lists.destroy
> end
```


### paranoia
11:36 paranoia教學
插件paranoia，可以做到我們軟刪除這件事

直接在wishlist的model加上這串acts_as_paranoid，就可以使用一堆語法
可以不一定要取名deleted_at 可以自己創造


***



許願卡留言功能
------


留言功能製作流程
1. 先整理留言功能有哪些欄位(user_id、wish_list_id、deleted_at、content)
2. 開Comment的model -> content:text、user:references、deleted_at:datetime:index、wish_list_id:integer
3. 開路徑 -> resources :comments, shallow: true, only: [:create, :destroy]
4. 建表單(先決定留言要在哪留言、誰可以留言) -> 表單post到comment的controller
5. comment的create、destroy製作(有很多細節要注意)
6. 許願卡show的action，要補上留言的顯示、刪除功能、scope可以直接避免軟刪除的資料不會被別人抓出來



### 第一步驟 整理欄位
comment(留言)
- belongs_to user
 - user_id
- belongs_to wish_list
 - wish_list_id
- content: text  
- deleted_at:datetime, index (軟刪除、假刪除 soft delete - 前台看不到、後台看不到，但是資料庫還是有)


留言model 

|欄位名稱|資料型態|說明|
|:-:|:-:|:-:|
|content|text|留言內容|
|wish_list_id|integer|哪一張許願卡的留言|
|user_id|integer|哪個使用者的留言|
|deleted_at|datetime|假刪除欄位|


> --  
> 做每一個model得時候，只要專注自己的model就好，要不然會太雜  
> --  
{: .block-tip}




### 第二步驟 開留言的model
```md
> rails g model Comment content:text deleted_at:datetime:index user:belongs_to wish_list:belongs_to
```




### 第三步驟 開留言功能的路徑

首先我們要來想一下，要把留言功能放在哪邊？  
雖然我們還沒有做可以讓多人可以看到同一個許願卡的頁面(目前只有做只能看到自己的許願卡)  
因此，就先做只有自己能留言的許願卡吧  

Ps. 未來要做到可以讓多人對同一個許願卡留言的功能  

**接著來看頁面，想要在wishlist的show頁面放一個表單(form)，這個form可以讓大家留言(此show頁面，就是comment的index頁面)**

所有我們到wish_list的show.html.erb，來加上留言功能的表單  
不過我們很快就遇到問題了！！留言表單的model、url是蝦咪  
```md
> <%= form_with model: ??, url: ?? do |form| %>
> <% end %>
```

首先model應該很好找，就是到wish_list的action，把comment的model新創造的實體傳到html.erb這邊
```md
> @comment = Comment.new
```

不過重點來了！！！！路徑是啥鬼
```md
> 首先我們來看一下目前show頁面的路徑

> /wish_lists/24                      # 後面24是許願卡的id(第24張許願卡)
```



照之前的經驗，我們直接到routes這樣寫，這樣就可以造出關於留言的路徑了
```md
> resources :comments
```

但這樣留言不就跟許願卡的連結脫鉤了嗎？照rails慣例，應該要改成下面這樣
```md
> resources :wish_lists do
>   resources :comments
>   end
> end
```


這樣是兩個model是有連結了，但是遇到下一個問題，就是路徑太雜亂了！！！
用留言的編輯路徑舉例
```md
> routes的路徑長這樣
> wish_lists/:wish_list_id/comments/:id/edit

> 真實連結
> wish_lists/24/comments/2/edit

> 上面連結這樣寫出來應該蠻好認的，就是第24張許願卡的第2則留言(但你看我要拆解成這樣才看得出來，證明太長了)
```


***


#### routes shallow介紹

有看rails官方文件，看到shallow的應該很好奇那是什麼東西的縮寫，現在馬上介紹一下  
根據前面有提到，路徑太長會很醜，並且也不好閱讀，所以是可以把一些路徑拆開的(有些可以跟著許願卡連結，有些可以分開)  

舉個例子：  
假設我今天想要把一則一則的留言show出來，就不需要許願卡的ID路徑，因為我只在意留言的ID  

反之像是new、create、index，我就會需要知道他是跟在誰的ID後面  
ex. 今天想要new一個新留言，我不知道許願卡的ID，怎麼知道這則留言是誰的  

因此可以把分類拆成下面兩段
```md
> resources :wish_lists do
>   resources :comments, only: [:new, :create, :index]
> end
> 
> resources :comments, only: [:show, :edit, :update, :destroy]
```


那shallow到底是什麼呢？其實就是上面拆成兩段的縮寫，像下面那樣寫上shallow，他可以自動幫你拆成上面兩段
```md
> resources :wish_lists do
>   resources :comments, shallow: true
> end
```


***


回到原本的許願卡路徑  
既然知道路徑會太長會很醜，我們先來決定留言功能有哪些action是需要用到的  
決定好有哪些action後，再來寫上路徑  
#### Comment的action篩選  

|action|是否需要|說明|
|:-:|:-:|:-:|
|index|X|許願卡show = 留言index|
|show|X|除非你會需要把每則留言點開來看|
|new|X|現在是建在許願卡show的erb上|
|create|O|一定要|
|edit|X/O|看情況，看你會不會允許修改留言|
|update|X/O|同上|
|destroy|O|通常可以刪除留言|
  
  
  
使用shallow把剛剛決定好的留言的action、路徑製作好
```md
> resources :wish_lists do
>   resources :comments, shallow: true, only: [:create, :destroy]
> end
```



### 第四步驟 建立留言表單
因此可以來把留言的表單寫完了
要特別注意，因為巢狀結構的關係，create的要抓的該許願卡當下的id
下面的表單會用到的@wish_list，真正抓到的是，目前登入者的id
```md
> @wish_list = current_user.wish_lists.find(params[:id])
```

把表單model、url寫上
```md
<%= form_with model: @comment, url: wish_list_comment_path(@wish_list) do |form| %>
    <%= form.label :content %>
    <%= form.text_field :content %>

    <%= form.submit %>
    
<% end %>
```


表單做好後，預期按鈕點下去，會送到comment的controller，因此來建立
建好後，我們先把create表單送過來的資料，印到畫面上
```md
> class CommentsController < ApplicationController
>   def create
>     render html: params
>   end
> end
```



接下來在controller補上一些方法
1. before_action :authenticate_user! -> 一定要登入才能留言
2. find_wish_list -> 要使用current_user來找:wish_list_id -> (想知道為啥wish_list_id，可以用params把create印出來)
3. comment_params -> 設定強參數
4. 到許願卡的model設定，has_many :comments


create那一段意思是，從許願卡的角度，產生出一個新的留言，並且要帶過濾後的參數進去  
Ps. new新留言的時候，記得要帶wish_list_id、user_id進去，要不然會寫不進去  

```md
> class CommentsController < ApplicationController
>   def create
>     @comment = @wish_list.comments.new(comment_params)    # 這一行寫進wish_list_id
>     @comment.user = current_user                          # 這一行寫進user_id
>   end
>   
>   if @comment.save
>     redirect_to wish_list_path(@wish_list), notice: "留言成功         # 成功存進留言，要返回許願卡show頁面
>   else
>   
>     # app/views/wish_lists/show.html.erb              # 要render許願卡的show介面
>     render "wish_lists/show"
>   end
> end
```


#### merge寫法介紹
不過上面那兩條id帶進進去的方式有點難看，來換一種寫法
使用merge可以直接把一個值，塞進hash裡面，並回傳新的hash，該hash是有塞進新值的

一個新hash
```md
> h = { :name=>123, :age=>18 }
```

原始把id塞進hash的方法
```md
> h[:user] = 1111

> p h               # { :name=>123, :age=>18, :user=>1111 }
```

新方法，使用merge，他可以跟另一個hash合併，並會回傳一個新hash
```md
> h.merge(cc: 123)

> p h               # { :name=>123, :age=>18, :cc=>123 }
```



因此最後的整留言個controller長這樣
```md
> class CommentsController < ApplicationController
> 
>   before_action :authenticate_user!                             # 驗證登入才能留言
>   before_action :find_wish_list only: [:create]                  
>   
>   def create
>       @comment = @wish_list.comments.new(comment_params)
>       # @comment.user = current_user
>   
>       if @comment.save
>         redirect_to wish_list_path(@wish_list), notice: "留言成功"
>       else
>         #render "wish_list/show"                                # 這一行可以修改成下面那樣
>         redirect_to wish_list_path(@wish_list),  alert: "請填寫留言"
>       end
>   
>   end
>   
>   
>   private
>   def find_wish_list
>       @wish_list = current_user.wish_lists.find(params[:wish_list_id])
>   end
>   
>   def comment_params
>       params.require(:comment).permit(:content).merge(user: current_user)      # 使用merge方法塞進去
>   end
>   
> end
```




### 第五步驟 增加限制 validates

對留言的content欄位增加必填限制
```md
> validates :content, presence: true
```





### 第六步驟 把留言顯示出來

已經可以創造新留言後，該來把留言印出來了，首先我們剛剛決定把留言顯示在許願卡的show頁面
也就是新增留言表單的正下方

那要怎麼做呢？
首先當然是到許願卡controller的show，把所有留言用實體傳道view

下面的意思是，該許願卡的id，把所有留言抓出來
```md
> def show
>   @comment = Comment.new
>   @comments = @wish_list.comments
> end
```


再來到show的view頁面，用迴圈印出全部東西

```md
> <ul>
>   @comments.each do |comment|
>     <li><%= comment.content %></li>
>   end
> </ul>
```



#### 留言顯示反轉

使用ord的功能，在留言抓出來的當下就是反轉的
```md
> def show
>   @comment = Comment.new
>   @comments = @wish_list.comments.ord(id: :desc)      -> 這樣就可以讓最新的留言在最上面
> end
```




***




下午的課 - 開始用老師的檔案

透過AJAX的方式

今天留言，重新redirect_to 到頁面，雖然非常快，但是還是會等一下

所以我們今天來做一個create.js.erb
這樣可以讓

假設今天在表單那邊，設定local: false，就可以讓


!!!因為我們form那邊，是用ajax送到erb那邊，因此我們create.js.erb，這樣可以在這個檔案裡面寫JS

這樣寫的好處是，不用換頁，就可以有結果了
Ps. controller那邊記得不能寫redirect_to or render，這樣才能連到create.js.erb



接著我們可以直接用create

直接用JS把裡面的東西塞進留言裡面
```md
var comments = docuent.querySelector(".comments")
var li = `<li><%= @comment.content %></li>`

comments.insertAdjacentHTML("afterbegin", li)
document.querySelector("#comment_content").value = ""
```



接下來把軟刪除掛上comment的model


掛上去後，可以在show頁面加上一個刪除按鈕
<%= link_to "刪除", comment_path(comment), method: "delete", data: {confirm: "sure????"} %>


並且增加destroy的action
刪除那邊要導回去的路徑，是每一張卡片show頁面，因此後面帶的id，可以用留言、許願卡的關聯去找
```md
> before_action :find_comment, only: [:destroy]
> 
> def destroy
>   @comment.destroy
>   redirect_to wish_list_path(@comment.wish_list), notice: "留言刪除"
> end
> 
> def find_comment
>   @comment = current_user.comments.find(params[:id])
> end
```






但是這樣寫，今天新增留言的時候，刪除功能會不見
所以使用render partial的功能

把show裡面的刪除功能，搬家搬到comment資料夾裡面
```md
<% @comments.each do |comment| %>
  <%= render "comments/comment", comment: comment %>
<% end %>
```


comment資料夾
```md
<li>
    <%= comment.content %>
    <%= link_to "刪除", comment_path(comment), method: "delete", data: {confirm: "sure????"} %>
</li>
```




不過這樣寫會以另外一個問題，效能很很爛
Ps. 因為目前是在迴圈裡面render，我們要來改另外一個寫法 - render collection



<%= render partial: "comments/comment", collection: @comments, as: comment %>
<%= render @comments %>



3:11 -> render partial的進階應用
原本寫法
```md
 <ul class="comments">
    <% @comments.each do |comment| %>
      <%= render "comments/comment", comment: comment %>
    <% end %>
  </ul>
```


改寫這段
var li = `<li><%= @comment.content %></li>`


改成這個 - 記得要用`才能執行
var li = `<%= render "comments/comment", comment: @comment %>`


或者是用
var li = "<li><%= j render "comments/comment", comment: @comment %></li>"








15:22
把刪除變成ajax的方法刪掉

先找尋link_to 有沒有local: false的方法

在data那邊加上remote: true，變成xml

_comment.html.erb
```md
> <li id="<%= dom_id(comment) %>">
>     <%= comment.content %>
>     <%= link_to "刪除", comment_path(comment), method: "delete", data: {confirm: "sure????", remote: true} %>
> </li>
```


destroy.js.erb
```md
> document.querySelector("#<%= dom_id(@comment)%>").remove()
```










15:25 加到我的最愛

首先在show頁面，加上一個按鈕

不過問題是，JS code要放在哪裡 -> JS檔案夾裡的application


15:45 -> 說明為啥要放在這，並且有些東西要注意，這樣寫會遇到script先後渲染、turbolinks的問題，所以我們換個方法
```md
> document.addEventListener("DOMContentLoaded", () =>{
>     var btn = document.querySelector("#loveBtn")
> 
>     if (btn) {
>         btn.addEventListener("click", (e) => {
>             console.log("hi");
>         })     
>     }
> 
> })
```




- JS寫哪裡
- 怎麼面對Turbolinks的生命週期

Stimulus.js可以解決上面兩件事

這個是一個微框架
在rails 寫 Stimulus.js


這一段執行會有一段時間是正常的，執行的時候會做一堆事情
因此要來請一個新工具，來幫我們打包，會快很多
有一個webpacker的gem，我們要用裡面的webpack工具


bin/webpack-dev-server
再開一個伺服器，可以幫助你打包東西，這樣會快超級多


有沒有一個套件，可以一次執行rails s、bin/webpack-dev-server
foreman這個套件可以

先安裝foreman後
bundle add foreman -> 這樣可以裝這個插件，他可以幫助我們一次執行上面兩個東西

去建立一個資料夾 - Procfile，裡面放的code為
```md
> web: bin/rails server -p 3000       # 執行rails s
> webpack: bun/webpack-dev-server     # 執行webpack
``

最後再執行，這樣就可以一次執行兩個server了
```md
> foreman start
```






把data-controller加在按鈕上，並新建一個資料夾ㄋㄋ

<button style= "padding: 10px 20px", data-controller="love-btn">
    no
</button>


兩個格式不一樣，要注意
love_btn_controller -> 資料夾名稱



我們來在按鈕那邊多增加幾個屬性 - data-action => 被點擊後，此按鈕會觸發gogo的fc
```md
> <button style= "padding: 10px 20px", data-controller="love-btn"
>                                      data-action="click->love-btn#toggle">
>
>     <span>no</span>
> </button>
```

```md
> toggle() {
>   console.log("good");
> }
```





接下來幫按鈕裡面的文字增加target，想要等等點擊下去，就可以更改no
這個target很好用，在這邊設定，就可以直接在JS那邊改他的內容
```md
> <button style= "padding: 10px 20px", data-controller="love-btn"
>                                         data-action="click->love-btn#toggle">
>     <span data-love-btn-target="text">no</span>       # 幫文字增加target
> </button>
```



要切換按鈕的兩種型態，需要給按鈕加上狀態，並用兩種狀態來判斷現在應該顯示哪種文字   
```md
> import { Controller } from "stimulus"
> 
> export default class extends Controller {
>   static targets = [ "text" ]
> 
>   initialize() {                                      # 給初始的狀態
>     this.btnState = false                             # 一開始的狀態先給false
>   }
> 
>   connect() {
>     // this.outputTarget.textContent = 'Hello, Stimulus!'
>     console.log(this.element);
>     
>     
>   }
> 
>   toggle() {
>     if (this.btnState) {                              # 假設按鈕狀態為true
>         this.textTarget.textContent = "NO"            # 文字為NO
>     } else {
>         this.textTarget.textContent = "YES"           # 反之，文字為Yes
>     }
> 
>     this.btnState = !this.btnState                    # 切換按鈕的狀態
>   }
> }
```











